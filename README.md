Простенькие задачи для тренировки функционального программирования

1. Проверьте, возможно ли изменить список в процессе итерирования.

2. Написать функцию, принимающую 2 списка и возвращающую декартово произведение
   (использовать itertools.product)
   
3. Написать функцию, принимающую строку s и число и возвращающую всевозможные перестановки 
из n символов в s строке в лексикографическом порядке(использовать itertools.permutations)
   
4. Реализовать функцию get_combinations. Должна принимать строку s и число k
и возвращать все возможные комбинации из символов в строке s с длинами <= k (itertools.combinations)
   
5. Функция должна принимать строку s и число k и возвращать все возможные комбинации 
из символов в строке s с длинами = k с повторениями ( использовать itertools.combinations)
   
6. Написать функцию, которая подсчитывает количество подряд идущих символов в строке 
   (использовать itertools.groupby)
   
7. В функцию передается список списков. Нужно вернуть максимум. который достигает выражение
   (a1*a1 + a2*a2 + an*an). Где ai -- максимальный элемент из iго списка.
   
8. Напишите генератор, выводящий первые n чисел Фибоначи.

9. Реализуйте аналог функций zip, map, enumerate.

10.Задача состоит в том, чтобы для входного списка списков получить список нечётных по порядку 
   списков (первый, третий и так далее), оставив в каждом только нечётные по порядку элементы. Например,
   для из списка [[1, 2, 3], [4, 5, 6], [7, 8, 9]] должен получиться список [[1, 3], [7, 9]].
   
   При этом функциональное решение должно вычислять новый список списков на основе оригинального.
   Оригинальный же список должен оставаться неизменным. У вас должна получиться функция odds_from_odds():
   
   Процедурное решение должно изменить список-аргумент по месту, а не возвращать его новую версию
   (возвращать вообще ничего не нужно!). Постарайтесь обойтись без создания вспомогательных структур
   в том числе и для обработки вложенных списков: процедурное решение должно быть эффективным с точки зрения
   использования памяти, ведь для этого мы такой код и пишем!
   У вас должна получиться процедура keep_odds_from_odds():


11. Вам предстоит написать функцию non_empty_truths(), которая с помощью генераторов списков должна вычислять
    копию входного списка списков, "очищенную" от ложных элементов (не только False, а любых ложных!),
    а заодно и от пустых списков — таковые могу присутствовать сами по себе или могут получаться после
    отбрасывания из них всех элементов.
    
12.Вам необходимо реализовать функцию number_of_unique_letters(), которая должна подсчитывать количество
   уникальных букв в строке-аргументе без учёта регистра.

13.Вам предстоит реализовать три функции, каждая из которых будет работать с двухмерной матрицей,
   то есть со списком списков (итератором итераторов).

   each2d(test, matrix) должна проверить, что каждый элемент матрицы matrix удовлетворяет предикату test,
      и вернуть False, если хотя бы для одного элемента test вернул False. В противном случае функция должна возвращать True.
   some2d(test, matrix) должна проверить, удовлетворяет ли предикату test хотя бы один элемент матрицы matrix.
      Как только test возвращает True для какого-либо элемента, функция должна вернуть True,
      в противном случае (если ни один элемент проверку не прошёл) нужно вернуть False.
   sum2d(test, matrix) должна возвращать сумму всех элементов матрицы matrix, удовлетворяющих предикату test.

   Внимание, первые две функции не должны выполнять лишней работы: обход матрицы должен прерываться,
   как только результат становится ясен.
   
14.Вам предстоит потренироваться в написании генераторных функций и написать три штуки:

   my_map(f, xs), которая должна работать как упрощённая версия map()
   my_filter(f, xs), упрощённый вариант filter()
   replicate_each(n, xs) должен для каждого элемента итератора xs выдавать на выход по n копий этого элемента# study_tasks
# study_tasks-
# study_tasks-
